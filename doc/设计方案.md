# 算法可视化平台设计方案

## 项目概述

"fuck-you-algorithm"是一个可扩展的算法可视化平台，旨在让开发者能够轻松接入自己的算法实现，并在前端获得美观的动态可视化效果。

## 核心特性

### 🚀 插件化算法接入
- 标准化API接口，新算法只需继承基类
- 自动注册机制，无需修改核心代码
- 支持多种算法类型（排序、搜索、图算法、动态规划等）

### 🎨 动态可视化
- 实时步骤展示
- 可控制的动画播放（播放/暂停/步进/回退）
- 交互式参数调节
- 性能指标实时监控

### 💻 现代化技术栈
- **后端**: Python FastAPI + SQLite
- **前端**: Vue 3 + TypeScript + D3.js + Element Plus
- **通信**: RESTful API + WebSocket
- **部署**: Docker容器化

## 系统架构

### 整体架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 (Vue3)    │◄──►│  后端 (FastAPI)  │◄──►│  算法插件系统    │
│                │    │                │    │                │
│ • 可视化组件     │    │ • RESTful API   │    │ • BaseAlgorithm │
│ • 控制面板      │    │ • WebSocket     │    │ • 自动注册      │
│ • 动画引擎      │    │ • 数据验证      │    │ • 配置管理      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 技术架构
```
前端层 (Frontend)
├── Vue 3 + Composition API    # 响应式框架
├── D3.js                     # 数据可视化
├── Element Plus              # UI组件库
├── Chart.js                  # 图表库
└── TypeScript                # 类型安全

API层 (Backend)
├── FastAPI                   # 高性能API框架
├── Pydantic                  # 数据验证
├── WebSocket                 # 实时通信
└── SQLAlchemy               # ORM

算法层 (Algorithm)
├── BaseAlgorithm            # 算法基类
├── AlgorithmRegistry        # 注册器
├── ConfigValidator          # 配置验证
└── StepTracker             # 步骤追踪
```

## 详细设计

### 1. 后端API设计

#### 核心接口
```python
# 算法基类
class BaseAlgorithm:
    def execute(self, data: Any, config: Dict) -> AlgorithmResult
    def get_steps(self) -> List[AlgorithmStep]
    def get_config_schema(self) -> Dict
    def get_metadata(self) -> AlgorithmMetadata

# API端点
GET  /api/algorithms                    # 获取算法列表
POST /api/algorithms/{name}/execute     # 执行算法
GET  /api/algorithms/{name}/config      # 获取算法配置
WS   /ws/algorithms/{name}/stream       # 实时数据流
```

#### 数据模型
```python
class AlgorithmStep:
    step_id: int
    action: str
    data_snapshot: Dict
    highlight: List[int]
    description: str
    timestamp: float

class AlgorithmResult:
    steps: List[AlgorithmStep]
    final_result: Any
    performance_metrics: Dict
    visualization_config: Dict
```

### 2. 前端架构设计

#### 组件层次
```
App.vue
├── HeaderNav.vue                 # 导航栏
├── AlgorithmList.vue            # 算法列表
├── AlgorithmWorkspace.vue       # 主工作区
│   ├── ControlPanel.vue         # 控制面板
│   ├── VisualizationArea.vue    # 可视化区域
│   │   ├── D3Renderer.vue       # D3渲染器
│   │   ├── ChartRenderer.vue    # 图表渲染器
│   │   └── AnimationController.vue # 动画控制
│   ├── ConfigPanel.vue          # 参数配置面板
│   └── MetricsPanel.vue         # 性能指标面板
└── Footer.vue                   # 页脚
```

#### 状态管理
```typescript
// Pinia Store
interface AlgorithmState {
  algorithms: Algorithm[]
  currentAlgorithm: Algorithm | null
  executionState: 'idle' | 'running' | 'paused' | 'completed'
  currentStep: number
  steps: AlgorithmStep[]
  config: Record<string, any>
  metrics: PerformanceMetrics
}
```

### 3. 算法接入规范

#### 标准算法实现
```python
from backend.core.base_algorithm import BaseAlgorithm
from backend.core.decorators import algorithm_register

@algorithm_register(
    name="bubble_sort",
    display_name="冒泡排序",
    category="sorting",
    description="经典的冒泡排序算法可视化"
)
class BubbleSortAlgorithm(BaseAlgorithm):
    def get_config_schema(self):
        return {
            "array_size": {"type": "integer", "min": 5, "max": 100, "default": 20},
            "delay": {"type": "number", "min": 0.1, "max": 2.0, "default": 0.5}
        }
    
    def execute(self, data, config):
        arr = data["array"]
        self.reset_steps()
        
        for i in range(len(arr)):
            for j in range(0, len(arr) - i - 1):
                # 记录比较步骤
                self.add_step(
                    action="compare",
                    data_snapshot={"array": arr.copy()},
                    highlight=[j, j + 1],
                    description=f"比较 {arr[j]} 和 {arr[j+1]}"
                )
                
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
                    # 记录交换步骤
                    self.add_step(
                        action="swap",
                        data_snapshot={"array": arr.copy()},
                        highlight=[j, j + 1],
                        description=f"交换 {arr[j+1]} 和 {arr[j]}"
                    )
        
        return self.create_result({"sorted_array": arr})
```

### 4. 可视化配置

#### 算法类型与可视化方案
```javascript
const visualizationConfigs = {
  sorting: {
    type: 'bar_chart',
    animations: ['compare', 'swap', 'highlight'],
    colors: {
      default: '#3498db',
      comparing: '#e74c3c',
      swapping: '#f39c12',
      sorted: '#27ae60'
    }
  },
  graph: {
    type: 'network_graph',
    animations: ['node_visit', 'edge_traverse', 'path_highlight'],
    layout: 'force_directed'
  },
  tree: {
    type: 'tree_diagram',
    animations: ['node_expand', 'path_trace'],
    orientation: 'top_bottom'
  }
}
```

### 5. 性能优化

#### 前端优化
- 虚拟化长列表渲染
- Canvas渲染大数据集
- 防抖动画控制
- 懒加载算法模块

#### 后端优化
- 异步算法执行
- 结果缓存机制
- WebSocket连接池
- 数据分页传输

## 开发计划

### Phase 1: 基础架构 (Week 1-2)
- [ ] 搭建FastAPI后端框架
- [ ] 创建Vue3前端项目
- [ ] 实现算法基类和注册系统
- [ ] 建立基础API通信

### Phase 2: 核心功能 (Week 3-4)
- [ ] 实现D3.js可视化组件
- [ ] 开发动画控制系统
- [ ] 创建参数配置面板
- [ ] 集成WebSocket实时通信

### Phase 3: 算法实现 (Week 5-6)
- [ ] 实现经典排序算法
- [ ] 添加图遍历算法
- [ ] 开发动态规划示例
- [ ] 创建性能监控面板

### Phase 4: 优化完善 (Week 7-8)
- [ ] 性能优化和测试
- [ ] UI/UX改进
- [ ] 文档完善
- [ ] Docker部署配置

## 目录结构

```
fuck-you-algorithm/
├── backend/                     # Python后端
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py             # FastAPI应用入口
│   │   ├── api/                # API路由
│   │   │   ├── __init__.py
│   │   │   ├── algorithms.py   # 算法相关API
│   │   │   └── websocket.py    # WebSocket处理
│   │   ├── core/               # 核心框架
│   │   │   ├── __init__.py
│   │   │   ├── base_algorithm.py
│   │   │   ├── registry.py
│   │   │   └── decorators.py
│   │   ├── algorithms/         # 算法实现
│   │   │   ├── __init__.py
│   │   │   ├── sorting/
│   │   │   ├── graph/
│   │   │   └── dynamic_programming/
│   │   ├── models/             # 数据模型
│   │   │   ├── __init__.py
│   │   │   ├── algorithm.py
│   │   │   └── response.py
│   │   └── utils/              # 工具函数
│   ├── requirements.txt
│   ├── requirements-dev.txt
│   └── Dockerfile
├── frontend/                    # Vue前端
│   ├── src/
│   │   ├── main.ts
│   │   ├── App.vue
│   │   ├── components/         # Vue组件
│   │   │   ├── common/
│   │   │   ├── visualization/
│   │   │   └── controls/
│   │   ├── views/              # 页面视图
│   │   │   ├── Home.vue
│   │   │   ├── Algorithm.vue
│   │   │   └── About.vue
│   │   ├── stores/             # Pinia状态管理
│   │   │   ├── algorithm.ts
│   │   │   └── ui.ts
│   │   ├── utils/              # 工具函数
│   │   │   ├── api.ts
│   │   │   ├── visualization.ts
│   │   │   └── animation.ts
│   │   ├── types/              # TypeScript类型定义
│   │   │   ├── algorithm.ts
│   │   │   └── visualization.ts
│   │   └── assets/             # 静态资源
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   └── Dockerfile
├── doc/                        # 文档
│   ├── 设计方案.md
│   ├── API文档.md
│   ├── 算法接入指南.md
│   └── 部署指南.md
├── docker-compose.yml          # 容器编排
├── README.md                   # 项目说明
├── CLAUDE.md                   # Claude指导文档
└── .gitignore
```

## 总结

这个设计方案提供了一个高度可扩展、易于使用的算法可视化平台。通过标准化的API接口和插件化架构，开发者可以轻松添加新的算法实现，同时获得专业级的可视化效果。

平台的核心优势：
1. **低门槛接入** - 只需实现几个标准方法
2. **高质量可视化** - 专业的动画和交互效果  
3. **强扩展性** - 支持各种算法类型
4. **现代化技术** - 使用最新的前后端技术栈